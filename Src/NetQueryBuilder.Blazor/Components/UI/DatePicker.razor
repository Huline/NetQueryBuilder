@namespace NetQueryBuilder.Blazor.Components.UI

<div class="@GetWrapperClass()" style="@Style">
    @if (!string.IsNullOrEmpty(Label))
    {
        <label class="nqb-datepicker-label @GetLabelClass()" for="@_inputId">
            @Label
            @if (Required && ShowRequiredAsterisk)
            {
                <span class="nqb-required-asterisk">*</span>
            }
        </label>
    }
    
    <div class="nqb-datepicker-input-container @GetInputContainerClass()">
        @if (StartAdornment != null)
        {
            <div class="nqb-datepicker-adornment nqb-datepicker-adornment-start">
                @StartAdornment
            </div>
        }
        
        <input @ref="_inputElement"
               id="@_inputId"
               type="@GetInputType()"
               class="@GetInputClass()"
               value="@GetStringValue()"
               @onchange="HandleChange"
               @oninput="HandleInput"
               @onfocus="HandleFocus"
               @onblur="HandleBlur"
               disabled="@Disabled"
               readonly="@ReadOnly"
               required="@Required"
               min="@GetMinValue()"
               max="@GetMaxValue()"
               step="@GetStepValue()" />
        
        @if (!ShowCalendarIcon)
        {
            <!-- Default calendar icon -->
            <div class="nqb-datepicker-calendar-icon">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 3H18V1H16V3H8V1H6V3H5C3.89 3 3.01 3.9 3.01 5L3 19C3 20.1 3.89 21 5 21H19C20.1 21 21 20.1 21 19V5C21 3.9 20.1 3 19 3ZM19 19H5V8H19V19ZM7 10H12V15H7V10Z" fill="currentColor"/>
                </svg>
            </div>
        }
        
        @if (EndAdornment != null || Adornment != null)
        {
            <div class="nqb-datepicker-adornment nqb-datepicker-adornment-end">
                @(EndAdornment ?? Adornment)
            </div>
        }
        
        @if (ShowClearButton && HasValue && !Disabled && !ReadOnly)
        {
            <button type="button" class="nqb-datepicker-clear-button" @onclick="ClearValue" tabindex="-1">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z" fill="currentColor"/>
                </svg>
            </button>
        }
    </div>
    
    @if (!string.IsNullOrEmpty(HelperText) && !Error)
    {
        <div class="nqb-datepicker-helper-text">
            @HelperText
        </div>
    }
    
    @if (Error && !string.IsNullOrEmpty(ErrorText))
    {
        <div class="nqb-datepicker-error-text">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="nqb-error-icon">
                <path d="M12 2C6.48 2 2 6.48 2 12S6.48 22 12 22S22 17.52 22 12S17.52 2 12 2ZM13 17H11V15H13V17ZM13 13H11V7H13V13Z" fill="currentColor"/>
            </svg>
            @ErrorText
        </div>
    }
</div>

@code {
    private ElementReference _inputElement;
    private string _inputId = $"nqb-datepicker-{Guid.NewGuid():N}";
    private bool _isFocused = false;

    // Core parameters
    [Parameter] public DateTime? Date { get; set; }
    [Parameter] public EventCallback<DateTime?> DateChanged { get; set; }
    [Parameter] public DateOnly? DateOnly { get; set; }
    [Parameter] public EventCallback<DateOnly?> DateOnlyChanged { get; set; }
    [Parameter] public TimeOnly? TimeOnly { get; set; }
    [Parameter] public EventCallback<TimeOnly?> TimeOnlyChanged { get; set; }
    [Parameter] public string? Label { get; set; }
    [Parameter] public string? HelperText { get; set; }
    [Parameter] public string? ErrorText { get; set; }
    [Parameter] public bool Error { get; set; }
    [Parameter] public bool Required { get; set; }
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public bool ReadOnly { get; set; }
    
    // Date configuration
    [Parameter] public DateTime? MinDate { get; set; }
    [Parameter] public DateTime? MaxDate { get; set; }
    [Parameter] public string PickerVariant { get; set; } = "date"; // "date", "datetime-local", "time"
    [Parameter] public int? StepMinutes { get; set; } // For time inputs
    [Parameter] public string DateFormat { get; set; } = "yyyy-MM-dd"; // Custom date format
    [Parameter] public string TimeFormat { get; set; } = "HH:mm"; // Custom time format
    
    // Styling and behavior
    [Parameter] public string Variant { get; set; } = "outlined"; // outlined, filled, standard
    [Parameter] public string Size { get; set; } = "medium"; // small, medium, large
    [Parameter] public string Density { get; set; } = "default"; // compact, default, spacious
    [Parameter] public bool Immediate { get; set; }
    [Parameter] public bool ShowClearButton { get; set; }
    [Parameter] public bool ShowCalendarIcon { get; set; } = true;
    [Parameter] public bool ShowRequiredAsterisk { get; set; } = true;
    [Parameter] public bool FullWidth { get; set; } = true;
    [Parameter] public bool OpenOnFocus { get; set; }
    
    // Adornments
    [Parameter] public RenderFragment? StartAdornment { get; set; }
    [Parameter] public RenderFragment? EndAdornment { get; set; }
    [Parameter] public RenderFragment? Adornment { get; set; } // Legacy support
    
    // Events
    [Parameter] public EventCallback<FocusEventArgs> OnFocus { get; set; }
    [Parameter] public EventCallback<FocusEventArgs> OnBlur { get; set; }
    [Parameter] public EventCallback<DateTime?> OnDateSelect { get; set; }
    
    // Customization
    [Parameter] public string? Class { get; set; }
    [Parameter] public string? Style { get; set; }

    private bool HasValue
    {
        get
        {
            return PickerVariant switch
            {
                "time" => TimeOnly.HasValue,
                _ => Date.HasValue || DateOnly.HasValue
            };
        }
    }

    private string GetWrapperClass()
    {
        var classes = new List<string> { "nqb-datepicker" };
        
        if (FullWidth) classes.Add("nqb-datepicker-fullwidth");
        if (Disabled) classes.Add("nqb-datepicker-disabled");
        if (ReadOnly) classes.Add("nqb-datepicker-readonly");
        if (Error) classes.Add("nqb-datepicker-error");
        if (_isFocused) classes.Add("nqb-datepicker-focused");
        
        classes.Add($"nqb-datepicker-{Variant}");
        classes.Add($"nqb-datepicker-{Size}");
        classes.Add($"nqb-datepicker-density-{Density}");
        classes.Add($"nqb-datepicker-{PickerVariant}");
        
        if (!string.IsNullOrEmpty(Class)) classes.Add(Class);
        
        return string.Join(" ", classes);
    }
    
    private string GetLabelClass()
    {
        var classes = new List<string>();
        
        if (_isFocused || HasValue) classes.Add("nqb-datepicker-label-focused");
        if (Error) classes.Add("nqb-datepicker-label-error");
        
        return string.Join(" ", classes);
    }
    
    private string GetInputContainerClass()
    {
        var classes = new List<string>();
        
        if (StartAdornment != null) classes.Add("nqb-datepicker-has-start-adornment");
        if (EndAdornment != null || Adornment != null) classes.Add("nqb-datepicker-has-end-adornment");
        if (ShowCalendarIcon) classes.Add("nqb-datepicker-has-calendar-icon");
        if (ShowClearButton && HasValue) classes.Add("nqb-datepicker-has-clear-button");
        
        return string.Join(" ", classes);
    }

    private string GetInputClass()
    {
        return "nqb-datepicker-input";
    }

    private string GetInputType()
    {
        return PickerVariant switch
        {
            "datetime-local" => "datetime-local",
            "time" => "time",
            _ => "date"
        };
    }

    private string GetStringValue()
    {
        return PickerVariant switch
        {
            "datetime-local" => Date?.ToString("yyyy-MM-ddTHH:mm") ?? "",
            "time" => TimeOnly?.ToString(TimeFormat) ?? "",
            _ => (Date?.ToString(DateFormat) ?? DateOnly?.ToString(DateFormat)) ?? ""
        };
    }
    
    private string? GetStepValue()
    {
        if (PickerVariant == "time" && StepMinutes.HasValue)
        {
            return (StepMinutes.Value * 60).ToString(); // Convert minutes to seconds
        }
        return null;
    }

    private string? GetMinValue()
    {
        if (MinDate.HasValue)
        {
            return PickerVariant switch
            {
                "datetime-local" => MinDate.Value.ToString("yyyy-MM-ddTHH:mm"),
                "time" => "00:00",
                _ => MinDate.Value.ToString("yyyy-MM-dd")
            };
        }
        return null;
    }

    private string? GetMaxValue()
    {
        if (MaxDate.HasValue)
        {
            return PickerVariant switch
            {
                "datetime-local" => MaxDate.Value.ToString("yyyy-MM-ddTHH:mm"),
                "time" => "23:59",
                _ => MaxDate.Value.ToString("yyyy-MM-dd")
            };
        }
        return null;
    }

    private async Task HandleFocus(FocusEventArgs e)
    {
        _isFocused = true;
        if (OnFocus.HasDelegate)
            await OnFocus.InvokeAsync(e);
    }
    
    private async Task HandleBlur(FocusEventArgs e)
    {
        _isFocused = false;
        if (OnBlur.HasDelegate)
            await OnBlur.InvokeAsync(e);
    }

    private async Task HandleInput(ChangeEventArgs e)
    {
        if (Immediate)
        {
            await UpdateValue(e.Value?.ToString());
        }
    }

    private async Task HandleChange(ChangeEventArgs e)
    {
        if (!Immediate)
        {
            await UpdateValue(e.Value?.ToString());
        }
    }
    
    private async Task UpdateValue(string? stringValue)
    {
        if (string.IsNullOrEmpty(stringValue))
        {
            await ClearAllValues();
            return;
        }

        try
        {
            switch (PickerVariant)
            {
                case "datetime-local":
                    if (DateTime.TryParse(stringValue, out var dateTime))
                    {
                        // Apply min/max constraints
                        if (MinDate.HasValue && dateTime < MinDate.Value)
                            dateTime = MinDate.Value;
                        else if (MaxDate.HasValue && dateTime > MaxDate.Value)
                            dateTime = MaxDate.Value;
                            
                        Date = dateTime;
                        if (DateChanged.HasDelegate) await DateChanged.InvokeAsync(Date);
                        if (OnDateSelect.HasDelegate) await OnDateSelect.InvokeAsync(Date);
                    }
                    break;
                    
                case "time":
                    if (System.TimeOnly.TryParse(stringValue, out var timeOnly))
                    {
                        TimeOnly = timeOnly;
                        if (TimeOnlyChanged.HasDelegate) await TimeOnlyChanged.InvokeAsync(TimeOnly);
                    }
                    break;
                    
                default: // date
                    DateTime? parsedDateTime = null;
                    DateOnly? parsedDateOnly = null;
                    
                    if (DateTime.TryParse(stringValue, out var tempDateTime))
                    {
                        // Apply min/max constraints
                        if (MinDate.HasValue && tempDateTime.Date < MinDate.Value.Date)
                            tempDateTime = MinDate.Value.Date;
                        else if (MaxDate.HasValue && tempDateTime.Date > MaxDate.Value.Date)
                            tempDateTime = MaxDate.Value.Date;
                            
                        parsedDateTime = tempDateTime.Date;
                    }
                    
                    if (System.DateOnly.TryParse(stringValue, out var tempDateOnly))
                    {
                        parsedDateOnly = tempDateOnly;
                    }
                    
                    if (parsedDateTime.HasValue)
                    {
                        Date = parsedDateTime;
                        if (DateChanged.HasDelegate) await DateChanged.InvokeAsync(Date);
                        if (OnDateSelect.HasDelegate) await OnDateSelect.InvokeAsync(Date);
                    }
                    
                    if (parsedDateOnly.HasValue)
                    {
                        DateOnly = parsedDateOnly;
                        if (DateOnlyChanged.HasDelegate) await DateOnlyChanged.InvokeAsync(DateOnly);
                    }
                    break;
            }
        }
        catch
        {
            // Invalid date format, ignore
        }
    }
    
    private async Task ClearAllValues()
    {
        Date = null;
        DateOnly = null;
        TimeOnly = null;
        
        if (DateChanged.HasDelegate) await DateChanged.InvokeAsync(null);
        if (DateOnlyChanged.HasDelegate) await DateOnlyChanged.InvokeAsync(null);
        if (TimeOnlyChanged.HasDelegate) await TimeOnlyChanged.InvokeAsync(null);
    }
    
    private async Task ClearValue()
    {
        await ClearAllValues();
        await _inputElement.FocusAsync();
    }
    
    // Public methods for external access
    public async Task FocusAsync() => await _inputElement.FocusAsync();
    public async Task ClearAsync() => await ClearValue();
}